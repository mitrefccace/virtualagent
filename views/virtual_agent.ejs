<!DOCTYPE html>
<html>

<head>
  <title>Virtual Agent</title>
  <link rel='stylesheet' href='/stylesheets/style.css' />
</head>

<body>
  <h1>Virtual Agent:
    <%= extension %>
  </h1>

  <div class="vid-border">
    remote
    <video style="" id="remoteView" width="320" height="240" autoplay></video>
  </div>
  <div class="vid-border">
    self
    <video style="" id="selfView" width="320" height="240" autoplay hidden muted></video>
  </div>






</body>
<script type="text/javascript" src="/assets/js/jquery.min.js"></script>
<script type="text/javascript" src="/assets/js/jssip.min.js"></script>
<script type="text/javascript" src="/assets/js/RecordRTC.min.js"></script>
<!-- Socket.io -->
<script src='/socket.io/socket.io.js'></script>
<script type="text/javascript">
  var calldata = '';
  var ua;
  var pc_config = '';
  var currentSession;
  var remoteStream = document.getElementById("remoteView");
  var selfStream = document.getElementById("selfView");
  var recorder;
  var startTime, endTime, totalTime, remotePlayPromise, selfPlayPromise;
  var debug = true; //console logs event info if true
  var jssip_debug = false; //enables debugging logs from jssip library if true NOTE: may have to refresh a lot to update change
  var socket;
  $(document).ready(function () {
    socket = io();
    socket.on('connect', function (data) {
      if (debug) console.log('Connected to socket.io');
      socket.emit('register-virtualagent', '<%= extension %>');
    }).on('registerJssip', function (data) {
      if (debug) console.log('Registering JSSIP\n' + data.ws + "|" + data.sipUri + "|" + data.pw + "|" + data.stun)
      register_jssip(data.ws, data.sipUri, data.pw, data.stun);
    }).on('newCall', function (data) {
      if (debug) console.log('newCall');
      localStorage.calldata = JSON.stringify(data);
      setTimeout(() => { accept_call(); }, 1000)
    }).on('disconnect', function (data) {
      if (debug) console.log('socket disconnect');
      // Something went wrong refresh the page.
      location.reload();
    });;
  });

  //setup for the call. creates and starts the User Agent (UA) and registers event handlers
  function register_jssip(ws_server, my_sip_uri, sip_password, stunServer) {
    if (stunServer)
      pc_config = stunServer;

    if (jssip_debug) JsSIP.debug.enable('JsSIP:*');
    else JsSIP.debug.disable('JsSIP:*');

    // Create our JsSIP instance and run it:
    var socket = new JsSIP.WebSocketInterface(ws_server);

    var configuration = {
      sockets: [socket],
      uri: my_sip_uri,
      password: sip_password
    };

    ua = new JsSIP.UA(configuration);
    ua.start();

    //the event handlers for UA events
    ua.on('newRTCSession', function (e) {
      currentSession = e.session;
      caller = e.request.from.uri.user;

      currentSession.on('accepted', function (e) {
        if (debug) console.log('\nCURRENTSESSION -  ACCEPTED: \nRESPONSE: \n' + e.response + "\nORIGINATOR:\n" +
          e.originator);
        start_self_video();
        var eventHandlers = {
          'succeeded': function (e) { console.log('PASSED ' + JSON.stringify(e)) },
          'failed': function (e) { console.log('FAILED ' + JSON.stringify(e)) }
        };

        var options = {
          'eventHandlers': eventHandlers
        };
        ua.sendMessage(caller, 'STARTRECORDING', options);

      });

      currentSession.on('ended', function (e) {
        if (debug) console.log('\nCURRENTSESSIOiN -  ENDED: \nMESSAGE:\n' + e.message + "CAUSE:\n" + e.cause);
        terminate_call();
      });


      currentSession.on('sdp', function (e) {
        //e.sdp = edit_request_with_packetizationmode(e.sdp);
      });



      currentSession.on('failed', function (e) {
        if (debug) console.log('\nCURRENTSESSION -  FAILED: \nMESSAGE:\n' + e.message + "\nCAUSE:\n" + e.cause +
          "\nORIGINATOR:\n" + e.originator);
        terminate_call();
      });

      //event listener for remote video. Adds to html page when ready. 
      //NOTE: has to be both here and in accept_call() because currentSession.connection is not established until after ua.answer() for incoming calls
      if (currentSession.connection) currentSession.connection.ontrack = function (e) {
        if (debug) console.log("STARTING REMOTE VIDEO\ne.streams: " + e.streams + "\ne.streams[0]: " + e.streams[
          0]);
        remoteStream.srcObject = e.streams[0];
        remotePlayPromise = remoteStream.play();
      };

    });
  }

  //answers an incoming call
  function accept_call() {
    if (debug) console.log("ACCEPT_CALL()");
    if (currentSession) {
      var options = {
        'mediaConstraints': {
          'audio': false,
          'video': true
        },
        'pcConfig': {
          'rtcpMuxPolicy': 'negotiate',
          'iceServers': [{
            'urls': [
              pc_config
            ]
          }]
        }
      };
      currentSession.answer(options);
      startTimer();

      //event listener for remote video. Adds to html page when ready. 
      //NOTE: needs to be both here and in the newRTCSession event listener because currentSession.connection is not established until after ua.answer() for incoming calls
      if (currentSession.connection) currentSession.connection.ontrack = function (e) {
        if (debug) console.log('ontrack:' + JSON.stringify(e));
        remoteStream.srcObject = e.streams[0];
        remotePlayPromise = remoteStream.play();
	remotePlayPromise.then(function(){
          playVideoFile('ready.webm')
          setTimeout(function () {
		currentSession.mute({
        		audio: false,
        		video: true
      		});
		setTimeout(function(){
            		setInterval(function(){playVideoFile('recording.webm');},3000)
            		playVideoFile('recording.webm');
            		record_call();
          	}, 500);
	  },3000);
        });
      };
    }
  }

  function playVideoFile(filename) {

    if (currentSession) {
      currentSession.mute({
        audio: false,
        video: true
      });
     
      // the following piece of code does not seem to stop the video at remote side
      if (window.self_stream) {
        if (window.self_stream.getVideoTracks()) {
          if (window.self_stream.getVideoTracks()[0]) {
            window.self_stream.getVideoTracks()[0].stop();
            console.log("videotrack[0] stopped");
          }
        }
      }

      selfStream.srcObject = null;
      selfStream.src = "videos/"+filename;
      selfStream.type = 'type="video/webm"';
      selfStream.setAttribute("loop", "true");

      //important - play() returns a Promise (async)
      var playPromise = selfStream.play();
      if (playPromise !== undefined) {
        playPromise.then(function () {
          //do not unmute until play() Promise returns
          currentSession.unmute({
            audio: false,
            video: true
          });
        }).catch(function (error) {
	  console.log(">>>>>>>>>>"+error)
          console.error('ERROR - this browser does not support play() Promise');
        });
      }

      selfStream.onplay = function () {
        // Set the source of one <video> element to be a stream from another.
        var stream = selfStream.captureStream();
        stream.onactive = function () {		// without onactive the tracks of captured stream may be empty
          // replace remote screen to be the captured stream
          var tracks = stream.getTracks();
           Promise.all(currentSession.connection.getSenders().map(sender => {
		if(sender&&sender.track&&stream)
            		sender.replaceTrack(stream.getTracks().find(t => t.kind == sender.track.kind), stream)
	   }));
        }
      };
    }
  }


  //starts the local streaming video. Works with some older browsers, if it is incompatible it logs an error message, and the selfStream html box stays hidden
  function start_self_video() {
    if (debug) console.log("Start Self Video");
    if (selfStream.hasAttribute("hidden")) //then the video wasn't already started
    {
      // Older browsers might not implement mediaDevices at all, so we set an empty object first
      if (navigator.mediaDevices === undefined) {
        navigator.mediaDevices = {};
      }

      // Some browsers partially implement mediaDevices. We can't just assign an object
      // with getUserMedia as it would overwrite existing properties.
      // Here, we will just add the getUserMedia property if it's missing.
      if (navigator.mediaDevices.getUserMedia === undefined) {
        navigator.mediaDevices.getUserMedia = function (constraints) {
          // First get ahold of the legacy getUserMedia, if present
          var getUserMedia = navigator.msGetUserMedia || navigator.getUserMedia || navigator.webkitGetUserMedia ||
            navigator.mozGetUserMedia;
          //var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

          // Some browsers just don't implement it - return a rejected promise with an error
          // to keep a consistent interface
          if (!getUserMedia) {
            return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
          }

          // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise
          return new Promise(function (resolve, reject) {
            getUserMedia.call(navigator, constraints, resolve, reject);
          });
        }
      }

      navigator.mediaDevices.getUserMedia({
        audio: false,
        video: true
      }).then(function (stream) {
        selfStream.removeAttribute("hidden");
        // Older browsers may not have srcObject
        if ("srcObject" in selfStream) {
          selfStream.srcObject = stream;
        } else {
          // Avoid using this in new browsers, as it is going away.
          selfStream.src = window.URL.createObjectURL(stream);
        }
        window.self_stream = stream;
        selfStream.onloadedmetadata = function (e) {
          selfPlayPromise = selfStream.play();
        };
      }).catch(function (err) {
        console.log(err.name + ": " + err.message);
      });
    }
  }

  //handles cleanup from jssip call. removes the session if it is active and removes video.
  function terminate_call() {
    if (currentSession) {
      if (!currentSession.isEnded()) currentSession.terminate();
    }
    console.log('terminate_call()');
    endTimer();
    remove_video();
    upload_call();
  }

  //removes both the remote and self video streams and replaces it with default image. stops allowing camera to be active. also hides call_options_buttons.
  function remove_video() {
    selfStream.setAttribute("hidden", true);
    if (remotePlayPromise !== undefined) {
      remotePlayPromise.then(_ => {
        remoteStream.pause();
        remoteStream.src = "";
      }).catch(error => {
        console.log("ERROR: remotePlayPromise");
      });
    }
    if (selfPlayPromise !== undefined) {
      selfPlayPromise.then(_ => {
        selfStream.pause();
        selfStream.src = "";
      }).catch(error => {
        console.log("ERROR: selfPlayPromise");
      });
    }

    //stops remote track
    if (remoteView.srcObject) {
      if (remoteView.srcObject.getTracks()) {
        if (remoteView.srcObject.getTracks()[0]) remoteView.srcObject.getTracks()[0].stop();
        if (remoteView.srcObject.getTracks()[1]) remoteView.srcObject.getTracks()[1].stop();
      }
    }

    //stops the camera from being active
    if (window.self_stream) {
      if (window.self_stream.getVideoTracks()) {
        if (window.self_stream.getVideoTracks()[0]) window.self_stream.getVideoTracks()[0].stop();
      }
    }

    navigator.mediaDevices.getUserMedia({
      audio: false,
      video: false
    });
  }

  // this function submits recorded blob to nodejs server
  function postFiles() {
    console.log('Post the file');
    var blob = recorder.getBlob();
    if (blob.size > 0) {
      console.log("Call Data: " + localStorage.calldata);
      var fileName = generateRandomString() + '.webm';
      var file = new File([blob], fileName, {
        type: 'video/webm'
      });

      xhr('/uploadFile', file, function (responseText) {
        console.info('FileUploaded: ' + responseText);
        location.reload();
      });
    } else {
      console.log("no data in video record");
      location.reload();
    }

  }
  // XHR2/FormData
  function xhr(url, data, callback) {
    var request = new XMLHttpRequest();
    request.onreadystatechange = function () {
      if (request.readyState == 4 && request.status == 200) {
        callback(request.responseText);
      }
    };

    request.open('POST', url);
    console.log("URL is: " + url);
    var formData = new FormData();
    formData.append('file', data);
    formData.append('calldata', localStorage.calldata);
    formData.append('callTime', totalTime);
    request.send(formData);
  }
  // generating random string
  function generateRandomString() {
    if (window.crypto) {
      var a = window.crypto.getRandomValues(new Uint32Array(3)),
        token = '';
      for (var i = 0, l = a.length; i < l; i++) token += a[i].toString(36);
      return token;
    } else {
      return (Math.random() * new Date().getTime()).toString(36).replace(/\./g, '');
    }
  }

  function record_call() {
    //currentSession.mute({audio:false, video:true});
    //setTimeout(()=>{currentSession.unmute({audio:false, video:true});},1000)
    recorder = RecordRTC(remoteStream.srcObject, {
      type: 'video'
    });
    recorder.startRecording();
    socket.emit('callAnswered', JSON.parse(localStorage.calldata).channel);
  };

  function upload_call() {
    if (typeof recorder != 'undefined'){
      recorder.stopRecording(postFiles);
    }else{
	console.log("Error call never recorded")
	location.reload()
    }
  };

  function startTimer() {
    startTime = new Date();
  };

  function endTimer() {
    endTime = new Date();
    var timeDiff = endTime - startTime; //in ms
    // strip the ms
    timeDiff /= 1000;

    // get seconds
    totalTime = Math.round(timeDiff);
    console.log(totalTime + " sec");
  }




  function edit_request_with_packetizationmode(request) {
    return request;
    console.log("EDITING SDP REQUEST from packetization-mode=1 to packetizationmode=0",request);

    if (request !== undefined) {
      var request_lines = request.split('\n');
      for (var i = 0; i < request_lines.length; i++) {
        //if (request_lines[i].includes("profile-level-id")) {
        if (request_lines[i].includes("fmtp:99")|request_lines[i].includes("profile-level-id")) {
          if (!request_lines[i].includes("packetization-mode")) { // add if does not include - Z20
            request_lines[i] = request_lines[i] + ";packetization-mode=0";
            console.log("ADD incoming SDP with packetization-mode=0");
          }

          if (request_lines[i].includes("packetization-mode=1")) { // change it to packetiation-mode 1
            request_lines[i].replace("packetization-mode=1", "packetization-mode=0");
            console.log("REPALCE with packetization-mode=0");
          }
        }

      }
      var new_request = request_lines.join('\n');
    } else {
      var new_request = request;
    }

    return new_request;
  }












</script>

</html>
